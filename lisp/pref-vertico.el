;;; pref-vertico --- Configurations for vertico
;;; Author: JY Lee
;;; Commentary:
;;
;;; Code:

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; custom consult commands
;;

(require 'consult nil t)
(defun pref.inner/consult-symbol-search (&optional initial)
  "Search for a matching line with `symbol-at-point' history support.
Candidates are hidden until input is provided.
INITIAL is initial search keyword.

Generated by Gemini 3.0.
Confirmed working with consult.el version 20260105.1624"
  (interactive)
  (let* ((curr-line (line-number-at-pos (point) consult-line-numbers-widen))
         ;; Pre-collect all candidates from the buffer, similar to `consult-line`.
         (candidates (consult--slow-operation "Collecting lines..."
                       (consult--line-candidates nil curr-line))))
    (consult--read
     (lambda (str pred action)
       (pcase action
         ('metadata
          '(metadata (category . consult-location)))
         ('t
          ;; We use `minibuffer-contents-no-properties` instead of `str`
          ;; to ensure filtering works correctly even if the cursor is
          ;; moved to the beginning of the input string.
          (let ((full-input (minibuffer-contents-no-properties)))
            (if (string= full-input "")
                nil ;; Hide candidates if input is empty
              ;; Use consult's filter (supports orderless, etc.) on all candidates
              (consult--completion-filter full-input candidates 'consult-location 'highlight))))
         (_
          (complete-with-action action candidates str pred))))
     :prompt "Symbol search: "
     :annotate (consult--line-fontify curr-line)
     :category 'consult-location
     :sort nil
     :require-match t
     ;; Populate history with the symbol at point.
     ;; This allows `M-n` to instantly grab the symbol under the cursor.
     :add-history (list (thing-at-point 'symbol))
     :history '(:input consult--line-history)
     ;; Custom lookup to pass the lexical `candidates` list to `consult--line-match`,
     ;; since the table above is a function, not a list.
     :lookup (lambda (selected _ input &rest _)
               (consult--line-match selected candidates input))
     :initial initial
     :state (consult--location-state candidates))))

(defun pref.inner/consult-find-up (&optional dir initial)
  "Search for files with `find' in DIR.
Press `C-l' to move up to the parent directory and restart the search.
If DIR is nil, use `default-directory'.
INITIAL is initial search keyword.

Generated by Gemini 3.0.
Confirmed working with consult.el version 20260105.1624"
  (interactive "P")
  (let* ((current-dir (or (and dir (if (stringp dir) dir (read-directory-name "Start dir: ")))
                          default-directory))
         (input initial)
         (continue t)
         (selected nil))

    ;; Loop to restart the search in the parent directory
    (while continue
      (setq current-dir (file-name-as-directory (expand-file-name current-dir)))
      
      (let ((map (make-sparse-keymap)))
        (set-keymap-parent map consult-async-map)
        ;; Bind `C-l` to throw a restart signal with the current input
        (define-key map (kbd "C-l")
          (lambda ()
            (interactive)
            (throw 'consult-find-up-restart
                   (cons :restart (minibuffer-contents-no-properties)))))
        
        (setq selected
              (catch 'consult-find-up-restart
                ;; Bind `default-directory` so the process runs in `current-dir`
                (let ((default-directory current-dir))
                  (consult--read
                   (consult--process-collection
                       ;; Pass "." instead of absolute path to ensure standard `find .` behavior.
                       ;; Context is handled by `default-directory`.
                       (consult--find-make-builder '("."))
                     :transform (consult--async-map (lambda (x) (string-remove-prefix "./" x)))
                     :highlight t
                     :file-handler t)
                   :prompt (format "Find in %s: " (abbreviate-file-name current-dir))
                   :sort nil
                   :require-match t
                   :initial input
                   :add-history (thing-at-point 'filename)
                   :category 'file
                   :history '(:input consult--find-history)
                   :keymap map))))
        
        (cond
         ;; Case 1: Restart signal caught (C-l pressed)
         ((and (consp selected) (eq (car selected) :restart))
          (setq input (cdr selected)
                ;; Move to parent directory
                current-dir (file-name-directory (directory-file-name current-dir))))
         ;; Case 2: A file was selected
         ((stringp selected)
          (setq continue nil)
          (find-file selected))
         ;; Case 3: User quit (C-g)
         (t
          (setq continue nil)))))
    nil))

(defun pref.inner/dont-check-remote (check)
  (unless (file-remote-p default-directory)
    (consult--default-project-function check)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Package configurations
;;

(use-package vertico :ensure t
  :bind (:map vertico-map
          ("C-l" . vertico-directory-up))
  :init
  (vertico-mode 1)
  :config
  (setopt vertico-cycle t
          vertico-resize nil))

(use-package marginalia :ensure t
  :init
  (setopt marginalia-align 'right)
  (marginalia-mode))

(use-package consult :ensure t
  :bind (("C-x b" . consult-buffer)
         ("C-s" . pref.inner/consult-symbol-search)
         ("C-c F" . pref.inner/consult-find-up)
         ("C-c l" . consult-line)
         ("C-c '" . consult-imenu))
  :init
  (keymap-global-set "C-c f"
                     (if (or (executable-find "fd")
                             (executable-find "fdfind"))
                         #'consult-fd
                       #'consult-find))
  
  (keymap-global-set "C-c r"
                     (if (executable-find "rg")
                         #'consult-ripgrep
                       #'consult-grep))
  :config
  (setopt consult-project-function #'pref.inner/dont-check-remote))

(use-package embark :ensure t
  :bind (("C-c ." . embark-act)
         :map minibuffer-local-map
            ("C-c C-o" . embark-export)))

(use-package embark-consult :ensure t
  :after embark)

(provide 'pref-vertico)
;;; pref-vertico.el ends here
